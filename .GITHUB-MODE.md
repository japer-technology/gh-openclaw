# OpenClaw GitHub Mode

## Executive Summary

OpenClaw GitHub Mode adds a second runtime plane where OpenClaw executes directly from repository commits inside GitHub Actions.

This specification defines:

- the product boundary between installed runtime and GitHub runtime
- the architecture and control contracts for GitHub execution
- parity rules so both planes share the same mental model
- security and governance controls required for production use
- measurable success criteria and non-goals

The core direction is simple: maximize real OpenClaw capability in GitHub while preserving installed runtime behavior.

---

## 1. Product Scope and Runtime Planes

### 1.1 Installed Runtime Plane (unchanged)

Installed OpenClaw continues to own:

- long-lived gateway processes
- persistent channel sessions
- local device and OS capabilities
- existing onboarding and app experiences

The installed runtime is the system of record for always-on interactive operation.

### 1.2 GitHub Runtime Plane (new)

GitHub Mode executes OpenClaw from checked-out code in workflows.

Primary use cases:

- pull request validation and regression checks
- command-driven automation from issue or PR comments
- scheduled policy, drift, and cost monitoring
- promotion workflows with approvals and attestations
- bot-generated pull requests

GitHub Mode is a repository runtime, not an installer runtime.

### 1.3 Hard invariants

1. No installed-runtime regressions caused by GitHub Mode codepaths.
2. Shared core logic is preferred over duplicate implementations.
3. All privileged operations are policy-gated and auditable.
4. GitHub-specific behavior must be explicit, adapter-based, and testable.

---

## 2. Product Goals and Non-goals

### 2.1 Primary goals

1. **Maximum functional coverage** in GitHub constraints.
2. **Experience convergence** between installed and GitHub operation.
3. **Policy-first execution** with deterministic evidence.
4. **Promotion confidence** via reproducible evaluations and attestations.

### 2.2 Explicit non-goals

- replacing installed runtime for always-on channel connectivity
- bypassing GitHub security primitives for convenience
- introducing hidden behavior divergence between runtime planes
- using GitHub Mode for direct writes to protected branches

---

## 3. Capability Taxonomy and Coverage Targets

Every installed feature is mapped into one of three classes.

### 3.1 Native (full parity)

Runs the same core path in GitHub with no meaningful semantic drift.

Target examples:

- route and policy contract validation
- fixture-driven eval suites
- deterministic scoring and threshold gates
- cost and latency envelope checks

### 3.2 Adapter (high fidelity)

Runs shared core orchestration with GitHub-safe adapters where host constraints exist.

Target examples:

- filesystem patch planning and PR artifact generation
- replayed inbound event simulation
- constrained tool execution in workflow sandboxes

### 3.3 Installed-only (explicit boundary)

Remains installed-runtime only until infrastructure enables safe parity.

Examples:

- persistent socket sessions for messaging channels
- hardware-bound device controls
- resident local UI integrations

### 3.4 Coverage objective

GitHub Mode should continuously reduce installed-only surface where safe and useful.
Any movement across categories requires parity, threat-model, and test updates.

---

## 4. Experience Convergence Model

To minimize operator context switching, both planes should align on four layers.

### 4.1 Intent layer

- shared command vocabulary (CLI and workflow command intents)
- shared routing semantics for scope, safety, and escalation

### 4.2 Visibility layer

- comparable run status, policy decisions, and execution traces
- deterministic summaries and artifacts per run

### 4.3 Contract layer

- equivalent contract directories for routing, policies, agents, eval, and attestations
- revision-addressable outputs tied to commit SHAs

### 4.4 Operations layer

- similar promotion lifecycle and incident handling mental model
- explicit documentation for any unavoidable differences

---

## 5. Architecture Overview

### 5.1 Shared runtime spine

GitHub Mode reuses the same core logic path where feasible:

1. orchestration (`src/auto-reply/reply`)
2. agent loop (`src/agents/pi-embedded-runner`)
3. tool-policy gates (`src/agents/tools`, `src/agents/pi-tools.ts`)
4. routing and channel abstractions (`src/routing`, `src/channels`, `src/gateway`)

### 5.2 GitHub overlay

- **Ingress**: issue comment, PR comment, workflow dispatch, schedule
- **Runtime**: shared orchestration plus constrained adapters
- **Adapters**: GitHub-safe implementations for tools and I/O
- **Egress**: checks, summaries, comments, bot PRs, artifacts, attestations

### 5.3 Adapter design rules

1. Keep adapter boundaries explicit and typed.
2. Preserve shared domain semantics and error contracts.
3. Produce deterministic, inspectable artifacts.
4. Fail closed when trust, policy, or secret prerequisites are missing.

---

## 6. Repository Contracts

GitHub Mode control surfaces:

- `routing/`: route profiles, canary and safe-mode rules
- `policies/`: safety and permission contracts
- `agents/`: profile and tool-scope contracts
- `datasets/`: eval fixtures and golden corpora
- `eval/`: scoring, thresholds, replay configuration
- `attestations/`: immutable promotion evidence
- `docs/ai/`: durable generated outputs
- `runtime/github/`: GitHub Mode manifests and policy wiring

Required baseline manifests in `runtime/github/`:

- `mode-manifest.json`: mode metadata and compatibility version
- `parity-matrix.json`: installed-to-GitHub feature classification
- `command-policy.json`: command intent to adapter and permission mapping
- `workflow-inventory.json`: declared workflows and trust class

---

## 7. Workflow Portfolio

### 7.1 Validation and quality

- `github-mode-build.yml`
- `github-mode-check.yml`
- `github-mode-test.yml`
- `github-mode-eval-tier0.yml`
- `github-mode-policy.yml`
- `github-mode-route-sim.yml`
- `github-mode-cost.yml`

### 7.2 Conversational execution

- `github-mode-command.yml`
- `github-mode-agent-run.yml`
- `github-mode-bot-pr.yml`

### 7.3 Promotion and operations

- `github-mode-promote-dev.yml`
- `github-mode-promote-staging.yml`
- `github-mode-promote-prod.yml`
- `github-mode-drift.yml`
- `github-mode-incident.yml`

Each workflow must publish:

- trust context (trusted or untrusted)
- policy version and manifest versions used
- key metrics and decision outcomes
- artifact links and retention class

---

## 8. Security and Governance Baseline

### 8.1 Secret and identity controls

- secrets only in GitHub Secrets or Environment Secrets
- no secrets in repo files, logs, artifacts, cache keys, or workflow inputs
- OIDC preferred over long-lived cloud credentials

### 8.2 Trust segmentation

- untrusted triggers run read-only without secrets
- trusted flows use minimal write scopes with explicit policy checks
- actor trust policy required for privileged commands

### 8.3 Workflow hardening

- explicit least-privilege `permissions:` in each workflow
- all third-party actions pinned to full commit SHA
- compliance checks fail on unsafe workflow configuration drift

### 8.4 Promotion controls

- environment protection and reviewers required for staging and prod
- promotion blocked unless required gates are green
- immutable attestation references mandatory for each promotion

---

## 9. Observability and Evidence

Every GitHub Mode run should emit consistent telemetry and artifacts.

Required outputs:

- normalized summary markdown
- machine-readable result payload
- policy decision log with deny reasons when relevant
- provenance metadata (commit, workflow, actor, mode manifest version)

Key metrics:

- parity coverage by class (`native`, `adapter`, `installed-only`)
- workflow reliability and flake rate
- command success and rejection rates
- promotion lead time and rollback frequency
- policy violation trend and mean time to remediation

---

## 10. Success Criteria and Definition of Done

GitHub Mode is considered production-ready when all are true:

1. Installed runtime baseline regression checks remain green.
2. Core GitHub workflows execute against shared runtime paths.
3. Security controls are enforced continuously by policy and CI checks.
4. Promotion is approval-gated and attestation-backed.
5. Parity matrix is maintained and demonstrates measurable progress.
6. Incident and drift workflows create actionable, auditable outputs.

### 10.1 Quality bar

A change to GitHub Mode is acceptable only when it improves one or more of:

- functional coverage
- safety and least privilege
- reliability and determinism
- operator clarity and auditability

without regressing installed runtime behavior.

---

## 11. Risks and Mitigations

- **Risk:** silent divergence between installed and GitHub semantics.
  - **Mitigation:** parity matrix ownership, mandatory parity checks, shared tests.
- **Risk:** privilege escalation through workflow misconfiguration.
  - **Mitigation:** permissions linting, trust segmentation, SHA pinning, approvals.
- **Risk:** brittle command automation from untrusted actors.
  - **Mitigation:** actor policy gates, constrained adapters, read-only fallback.
- **Risk:** weak forensic quality during incidents.
  - **Mitigation:** standardized evidence schema and attestation verification.

---

## 12. Ownership and Change Management

- Changes to `runtime/github/*` contracts require review from runtime and security owners.
- Any expansion of privileged workflow scopes requires explicit rationale and threat-model update.
- Any reduction in controls is prohibited without compensating safeguards and approval.
- Parity matrix owners must review every feature classification change.
