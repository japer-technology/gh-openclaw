# OpenClaw GitHub Mode Implementation Plan

## Executive Summary

This plan operationalizes `.GITHUB-MODE.md` into an auditable delivery sequence.

Design principles:

- protect installed runtime behavior first
- maximize GitHub functional coverage through shared core paths
- enforce least privilege and trust-aware execution
- ship measurable milestones with strict entry and exit criteria

---

## 1. Program Governance

### 1.1 Workstreams

1. **Runtime parity**: shared codepaths, adapter boundaries, parity checks.
2. **Security and trust**: secrets, permissions, OIDC, action pinning, actor policy.
3. **Workflow platform**: validation, command automation, promotion, incident workflows.
4. **Evidence and operations**: attestations, observability, drift detection, runbooks.

### 1.2 Ownership model

Each phase requires a named owner for:

- runtime architecture
- security controls
- workflow platform
- operational readiness

No phase exits without owner sign-off.

### 1.3 Release strategy

- feature-gate GitHub Mode capabilities behind explicit runtime flags
- ship incrementally with rollback-safe defaults
- require green baseline checks for installed runtime on every phase merge

---

## 2. Phase Gates and Global Quality Criteria

Every phase must satisfy all of the following:

1. deterministic artifacts published for review
2. policy and trust decisions visible in summaries
3. tests for positive and negative paths
4. rollback path documented
5. no installed runtime regression introduced

Global stop conditions:

- unresolved security control drift
- untriaged high-severity workflow failures
- parity matrix stale beyond agreed review window

---

## 3. Phase 0: Baseline and Discovery

### Objectives

- establish current-state inventory and risk profile
- prevent accidental coupling to installed runtime behavior

### Deliverables

- workflow inventory with trust classification
- preliminary threat model for GitHub execution
- baseline regression suite for installed runtime
- draft parity matrix structure

### Exit criteria

- inventory approved by runtime and security owners
- baseline regression checks running in CI
- initial threat model reviewed and accepted

---

## 4. Phase 1: Contract and Parity Foundations

### Step 1.1 Create GitHub Mode contract scaffold

Create `runtime/github/` with:

- `mode-manifest.json`
- `parity-matrix.json`
- `command-policy.json`
- `workflow-inventory.json`

Add schema validation checks and compatibility versioning.

### Step 1.2 Build parity matrix workflow checks

Implement parity CI checks that:

- require every installed feature to be classified (`native`, `adapter`, `installed-only`)
- require owner and rationale fields
- reject stale review timestamps
- compute and publish parity scorecards

### Step 1.3 Add GitHub Mode capability flags

- add explicit runtime flags for GitHub adapters
- default all new flags to preserve installed behavior
- add tests proving no implicit activation in installed runtime

### Step 1.4 Add convergence mapping

Define machine-readable mapping from installed primitives to GitHub primitives.
Fail CI for unmapped high-value workflows.

### Exit criteria

- contract scaffold merged with schema checks
- parity checks green and enforced
- capability flags covered by tests
- convergence mapping artifact generated in CI

---

## 5. Phase 2: Security and Trust Foundation

### Step 2.1 Secret inventory and handling rules

Publish a secret inventory table with:

- secret name
- environment scope (`github-mode-dev`, `github-mode-staging`, `github-mode-prod`)
- rotation owner
- rotation cadence

Enforce policy: no secrets in source, logs, artifacts, or cache keys.

### Step 2.2 Environment protections

Configure and enforce:

- required reviewers for staging and prod
- branch and tag restrictions per environment
- approval gates in promotion workflows

### Step 2.3 Workflow permission hardening

For every workflow:

- explicit least-privilege `permissions:` block
- no inherited broad defaults
- trust segmentation for untrusted vs trusted contexts

### Step 2.4 OIDC rollout

Replace static cloud credentials with OIDC where possible.
Restrict claims by repository, ref, and environment.

### Step 2.5 Third-party action pinning

- pin all third-party actions by full commit SHA
- fail CI on unpinned actions
- add scheduled update workflow with controlled review

### Step 2.6 Actor authorization policy

Define and enforce trusted actor rules for privileged commands.
Untrusted actors receive constrained read-only execution.

### Exit criteria

- security checklist controls enforced by automated checks
- no privileged workflow can run without trust and policy prerequisites
- secrets never exposed in untrusted triggers

---

## 6. Phase 3: Validation, Simulation, Eval, and Cost

### Step 3.1 Validation workflows

Implement:

- `github-mode-build.yml`
- `github-mode-check.yml`
- `github-mode-test.yml`

Requirements:

- deterministic execution and artifacts
- fork-safe behavior with no secrets
- consistent summary format

### Step 3.2 Policy and route simulation workflows

Implement:

- `github-mode-policy.yml`
- `github-mode-route-sim.yml`

Requirements:

- evaluate contracts in `routing/`, `policies/`, `agents/`
- machine-readable reports and markdown summaries
- fail on unsafe policy expansion or drift

### Step 3.3 Eval and cost workflows

Implement:

- `github-mode-eval-tier0.yml`
- `github-mode-cost.yml`

Requirements:

- fixture and replay execution from `datasets/` and `eval/`
- scorecard outputs with regression deltas
- budget and threshold gate enforcement

### Exit criteria

- all workflows green in trusted and untrusted paths
- promotion-precheck reports available and stable
- parity matrix updated with validated coverage changes

---

## 7. Phase 4: Command, Agent-run, and Bot PR Loops

### Step 4.1 Command workflow

Implement `github-mode-command.yml` for `explain`, `refactor`, `test`, and `diagram` intents.

Requirements:

- parse command source and context
- evaluate actor trust and repo state trust
- select adapter set based on command-policy contract

### Step 4.2 Constrained agent run

Implement `github-mode-agent-run.yml`.

Requirements:

- invoke shared orchestration path with adapters
- enforce `runtime/github/command-policy.json`
- emit signed or verifiable execution summaries

### Step 4.3 Bot PR workflow

Implement `github-mode-bot-pr.yml`.

Requirements:

- create branch-scoped outputs only
- include provenance metadata (command, SHA, policy version)
- never write directly to protected branches

### Exit criteria

- trusted commands execute end-to-end with auditable outputs
- rejected commands provide clear deny reasons
- bot PRs include complete provenance metadata

---

## 8. Phase 5: Promotion, Attestation, and Incident Operations

### Step 5.1 Promotion workflows

Implement:

- `github-mode-promote-dev.yml`
- `github-mode-promote-staging.yml`
- `github-mode-promote-prod.yml`

Requirements:

- environment approvals required
- mandatory green prerequisite checks
- immutable artifact references in promotion logs

### Step 5.2 Attestation lifecycle

Implement attestation generation and verification in `attestations/`.

Required fields:

- commit and environment revisions
- policy, routing, and agent contract revisions
- model IDs and dataset hashes
- eval summary and budget envelope
- approvers and timestamp

### Step 5.3 Drift and incident workflows

Implement:

- `github-mode-drift.yml`
- `github-mode-incident.yml`

Requirements:

- scheduled drift checks for policies, routes, evals, and budgets
- auto-created issues with severity and evidence links
- optional promotion lock on severe drift

### Exit criteria

- promotion path cannot bypass attestations
- drift incidents are actionable and reproducible
- rollback workflow tested and documented

---

## 9. Phase 6: Adapter and Emulation Expansion

### Step 6.1 Build adapter library

Implement and harden adapters for:

- filesystem patch planning
- docs generation
- route simulation
- replayed inbound events

### Step 6.2 Build emulation harnesses

Add replay and mock harnesses for channel events and memory stores.
Track per-subsystem fidelity score and confidence trend.

### Step 6.3 Reduce installed-only surface

For each migration candidate:

- update parity matrix and threat model
- add tests and acceptance criteria
- document any semantic differences

### Exit criteria

- measurable parity improvement from previous release
- no new security exceptions introduced
- fidelity scores published and reviewed

---

## 10. Phase 7: Observability and Continuous Compliance

### Step 7.1 Standardize telemetry and evidence

Define schema for summaries and artifacts.
Publish run-level metadata for traceability.

### Step 7.2 Compliance automation

Mandatory checks fail when:

- permissions are over-broad
- actions are not SHA-pinned
- secrets are reachable from untrusted contexts
- environment protections are bypassed

### Step 7.3 Operational runbooks

Maintain and rehearse playbooks for:

- key and secret rotation
- emergency credential revocation
- workflow token compromise response
- attestation audit and rollback

### Exit criteria

- compliance failures are blocking and owned
- runbooks validated through tabletop or dry-run exercises
- incident response metrics reported

---

## 11. Security Requirements Checklist

All must be continuously true before general availability:

1. API keys exist only in GitHub Secrets or Environment Secrets.
2. No secrets are exposed to fork pull request workflows.
3. Privileged workflows require trust or environment approval gates.
4. Third-party actions are pinned by full commit SHA.
5. `GITHUB_TOKEN` scopes are explicit and least privilege.
6. OIDC is used in place of long-lived cloud credentials where available.
7. Protected branches are never directly written by bots.
8. Promotions require successful gates and verified attestations.
9. Logs and artifacts are scrubbed for secret leakage risk.
10. Security linting enforces all above rules continuously.

---

## 12. Milestones and Readiness Signals

- **M1**: contracts, parity matrix, threat model, baseline checks
- **M2**: security and trust foundation complete
- **M3**: validation, policy, route, eval, and cost workflows live
- **M4**: command, agent-run, and bot PR loop live
- **M5**: promotion, attestation, drift, and incident workflows live
- **M6**: adapter expansion and parity score growth demonstrated

Readiness requires positive trend on:

- parity coverage
- reliability and flake reduction
- policy compliance
- promotion confidence and rollback safety

---

## 13. Definition of Done

GitHub Mode implementation is complete when:

1. installed runtime behavior remains stable under regression gates
2. GitHub workflows deliver high-value shared-runtime capability
3. security controls are automated, enforceable, and auditable
4. promotion and incident operations are approval-gated and evidence-backed
5. parity matrix governance is active with measurable forward progress
